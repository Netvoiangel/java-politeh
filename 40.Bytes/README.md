### Практика #1: Пример использования `InputStream`

Для демонстрации работы метода `read()` класса `InputStream`, можно использовать один из его подклассов, например, `FileInputStream`. В этом примере программа читает данные из файла побайтово.

### Практика #2: Пример использования `OutputStream`

Для демонстрации работы метода `write(int)` класса `OutputStream`, можно использовать класс `FileOutputStream`, который записывает данные в файл:

### Практика #3: Зачем дополнительные иерархии `Reader` и `Writer`

`InputStream` и `OutputStream` предназначены для работы с **байтовыми** данными, а **Reader** и **Writer** — с **символьными** данными. Причины для разделения этих иерархий:

- **Символы** могут представлять собой многобайтовые последовательности (например, UTF-8), и операции над ними требуют использования кодировок.
- **InputStream** и **OutputStream** работают с байтовыми потоками, которые лучше всего подходят для бинарных данных (например, изображения, аудио и видео файлы).
- **Reader** и **Writer** ориентированы на текстовые данные и автоматически используют кодировки, что упрощает работу с текстом.

Таким образом, `Reader` и `Writer` предоставляют более высокоуровневые механизмы для работы с текстом, чем байтовые потоки.

### Практика #4: Зачем нужен интерфейс `AutoCloseable`?

Интерфейс `AutoCloseable` используется для того, чтобы объекты могли быть автоматически закрыты после завершения работы с ними, что часто используется в блоках `try-with-resources`.

Пример:

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class AutoCloseableExample {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Здесь:
- `BufferedReader` реализует интерфейс `AutoCloseable`, и его метод `close()` автоматически вызывается в конце работы с ресурсом, гарантируя, что файл будет закрыт, даже если возникнет исключение.
